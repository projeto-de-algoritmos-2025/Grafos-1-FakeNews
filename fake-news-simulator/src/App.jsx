import { useState, useEffect } from 'react';
import ForceGraph2D from 'react-force-graph-2d';
import { myGraphData } from './data';
import manAvatar from '../public/avatars/man.png';
import womanAvatar from '../public/avatars/woman.png';
import influencerIcon from '../public/groups/influencer.png';
import familyIcon from '../public/groups/family.png';
import followerIcon from '../public/groups/follower.png';
import friendIcon from '../public/groups/friend.png';
  const avatarMap = {
    'man.png': manAvatar,
    'woman.png': womanAvatar
  };
  const groupIconMap = {
    'Influencer': influencerIcon,
    'Family': familyIcon,
    'Follower': followerIcon,
    'Friend': friendIcon
  };

function App() {
  // useState receives an initial state and returns an array with the current state and a function to update it upon changes, which is destructured into two variables
  const [graphData, setGraphData] = useState({ nodes: [], links: [] });
  const [infectedNodes, setInfectedNodes] = useState({});
  const [bfsQueue, setBfsQueue] = useState([]);
  const [intensity, setIntensity] = useState(0.5); // Valor inicial entre 0 e 1

  // TO DO:
  // 1. Keep the colouring by groups?
  // 2. Ensure that the red color is used exclusively for infected nodes - done
  // 3. Should all the logic be here in the App.jsx? - fuck it, yes
  // 4. improve on the probability of misinformation spread
  // 5. show the tree generated by the BFS?
  // 6. Improve the fake news dynamic?
  // 7. Função pra gerar os nós e links?

  // watch out for changes in myGraphData and update graphData on re-rendering
  useEffect(() => {
    setGraphData(myGraphData);
  }, []);

  useEffect(() => {
    if (bfsQueue.length === 0) return;

    // "dequeue"
    const { id, step } = bfsQueue[0];
    const newNodesToInfect = [];
    
    // getting neighbour nodes
    const outgoingLinks = graphData.links.filter(
      link => (link.source.id || link.source) === id
    );

    console.log('passando por aqui')
    
    // run BFS
    for(const link of outgoingLinks){
      const neighbourId = link.target.id;
      const probability = link.weight + intensity;
      
      // checks the node, marks and enqueue it
      if(!infectedNodes.hasOwnProperty(neighbourId) && Math.random() < Math.min(1,probability)) {
        newNodesToInfect.push({id: neighbourId, step: step + 1})
      }
    }

    setTimeout(() => {
      // this was kind of complex for me, "prev" is passed by react. React keeps watch of the value of all of variables that are using useState. So prev is actually the current value, that will be the previous value upon "return"
      setInfectedNodes( prev => {
        const newInfected = { ...prev };
        newNodesToInfect.forEach(node => {
          newInfected[node.id] = node.step;
        });
        return newInfected;
      })

      setBfsQueue(prevQueue => {
        // dequeueing for real 
        const newQueue = prevQueue.slice(1);
        return [...newQueue, ...newNodesToInfect];
      });
    // spread delay
    }, 750);
  }, [bfsQueue, infectedNodes, graphData])

  const handleNodeClick = (node) => {
    // Resets the graph and calls useEffect()
    setInfectedNodes({ [node.id]: 0 });
    setBfsQueue([{ id: node.id, step: 0 }]);
  };

  // both linkColor and nodeColor are called upon re-rendering of App() and catch the change of state/value in infectedNodes 
  // will override the auto coloring by group, but we can deal with that later (TO DO: 1)
  const nodeColor = node => {return infectedNodes.hasOwnProperty(node.id) ? 'red' : 'lightgrey'}

  const linkColor = link => {
    const sourceInfected = infectedNodes.hasOwnProperty(link.source.id);
    const targetInfected = infectedNodes.hasOwnProperty(link.target.id);

    if (sourceInfected && targetInfected) {
      return 'orange';
    }
    return 'lightgreen'
  }

  return (
    <>
      {/* Legenda dos grupos */}
      <div style={{
        position: 'absolute',
        top: 20,
        left: 20,
        background: 'rgba(255,255,255,0.9)',
        border: '1px solid #ccc',
        borderRadius: '8px',
        padding: '12px 18px',
        zIndex: 10,
        boxShadow: '0 2px 8px rgba(0,0,0,0.08)',
        color: 'black'
      }}>
        <div style={{ fontWeight: 'bold', marginBottom: 8, color: 'black' }}>Legenda dos Grupos</div>
        <div style={{ display: 'flex', flexDirection: 'column', gap: 6 }}>
          <span style={{ display: 'flex', alignItems: 'center', gap: 8, color: 'black' }}>
            <img src={influencerIcon} alt="Influencer" width={20} height={20} /> Influencer
          </span>
          <span style={{ display: 'flex', alignItems: 'center', gap: 8, color: 'black' }}>
            <img src={familyIcon} alt="Family" width={20} height={20} /> Family
          </span>
          <span style={{ display: 'flex', alignItems: 'center', gap: 8, color: 'black' }}>
            <img src={followerIcon} alt="Follower" width={20} height={20} /> Follower
          </span>
          <span style={{ display: 'flex', alignItems: 'center', gap: 8, color: 'black' }}>
            <img src={friendIcon} alt="Friend" width={20} height={20} /> Friend
          </span>
        </div>
      </div>
      <div style={{ padding: '5px',textAlign: 'center' }}>
        <h2>Simulação de Propagação de Fake News</h2>
        <p>Nós Atingidos: {Object.keys(infectedNodes).length} de {graphData.nodes.length}</p>
        <p>Passos da Propagação: {Math.max(0, ...Object.values(infectedNodes))}</p>
      </div>

      <div style={{ padding: '5px',textAlign: 'center' }}>
        <label>Intensidade da Fake News:</label>
        <input 
          type="range" 
          min="0" 
          max="1" 
          step="0.01" 
          value={intensity} 
          onChange={(e) => setIntensity(parseFloat(e.target.value))}
        />
        <span>{intensity.toFixed(2)}</span>
      </div>
      <div style={{ width: '100vw', height: '100vh'}}>
        <ForceGraph2D
          graphData={graphData}
          nodeLabel="id"
          linkLabel="weight"
          linkDirectionalArrowLength={3.5}
          linkDirectionalArrowRelPos={1}
          onNodeClick={handleNodeClick}
          nodeColor={nodeColor}
          linkColor={linkColor}
          nodeCanvasObject={(node, ctx, globalScale) => {
            // Escolhe avatar pelo nome (alternando para exemplo)
            const img = new window.Image();
            img.src = (node.id === 'Alice' || node.id === 'Carla' || node.id === 'Eva' || node.id === '7' || node.id === '9') ? womanAvatar : manAvatar;
            // Ícone do grupo
            const groupImg = new window.Image();
            groupImg.src = groupIconMap[node.group] || friendIcon;

            // Desenha círculo colorido (infectado ou não)
            ctx.save();
            ctx.beginPath();
            ctx.arc(node.x, node.y, 12, 0, 2 * Math.PI, false);
            ctx.closePath();
            ctx.lineWidth = 2;
            ctx.strokeStyle = infectedNodes.hasOwnProperty(node.id) ? 'red' : 'lightgrey';
            ctx.stroke();
            ctx.clip();
            ctx.drawImage(img, node.x - 10, node.y - 10, 20, 20);
            ctx.restore();

            // Desenha ícone do grupo (canto inferior direito)
            ctx.save();
            ctx.beginPath();
            ctx.arc(node.x + 8, node.y + 8, 5, 0, 2 * Math.PI, false);
            ctx.closePath();
            ctx.clip();
            ctx.drawImage(groupImg, node.x + 3, node.y + 3, 10, 10);
            ctx.restore();

            // Nome do nó
            ctx.font = `${12/globalScale}px Sans-Serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillStyle = 'white';
            ctx.fillText(node.id, node.x, node.y + 16);
          }}
        />
      </div>
    </>
  );
}

export default App;