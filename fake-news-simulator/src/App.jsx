import { useState, useEffect } from 'react';
import ForceGraph2D from 'react-force-graph-2d';
import { myGraphData } from './data';

function App() {
  // useState receives an initial state and returns an array with the current state and a function to update it upon changes, which is destructured into two variables
  const [graphData, setGraphData] = useState({ nodes: [], links: [] });
  const [infectedNodes, setInfectedNodes] = useState({});
  const [bfsQueue, setBfsQueue] = useState([]);
  
  // TO DO:
  // 1. Keep the colouring by groups?
  // 2. Ensure that the red color is used exclusively for infected nodes
  // 3. Should all the logic be here in the App.jsx?
  // 4. improve on the probability of misinformation spread
  // 5. show the tree generated by the BFS?
  // 6. Improve the fake news dynamic?

  // watch out for changes in myGraphData and update graphData on re-rendering
  useEffect(() => {
    setGraphData(myGraphData);
  }, []);

  useEffect(() => {
    if (bfsQueue.length === 0) return;

    // "dequeue"
    const { id, step } = bfsQueue[0];
    const newNodesToInfect = [];
    
    // getting neighbour nodes
    const outgoingLinks = graphData.links.filter(
      link => (link.source.id || link.source) === id
    );

    // run BFS
    for(const link of outgoingLinks){
      const neighbourId = link.target.id;
      const probability = link.weight;
      
      // checks the node, marks and enqueue it
      if(!infectedNodes.hasOwnProperty(neighbourId.id) && 0.1 < probability) {
        newNodesToInfect.push({id: neighbourId.id, step: step + 1})
      }
    }

    setTimeout(() => {
      // this was kind of complex for me, "prev" is passed by react. React keeps watch of the value of all of variables that are using useState. So prev is actually the current value, that will be the previous value upon "return"
      setInfectedNodes( prev => {
        const newInfected = { ...prev };
        newNodesToInfect.forEach(node => {
          newInfected[node.id] = node.step;
        });
        return newInfected;
      })

      setBfsQueue(prevQueue => {
        // dequeueing for real 
        const newQueue = prevQueue.slice(1);
        return [...newQueue, ...newNodesToInfect];
      });
    // spred delay
    }, 500);
  }, [bfsQueue, infectedNodes, graphData])

  const handleNodeClick = (node) => {
    // Resets the graph and calls useEffect()
    setInfectedNodes({ [node.id]: 0 });
    setBfsQueue([{ id: node.id, step: 0 }]);
  };

  // both linkColor and nodeColor are called upon re-rendering of App() and catch the change of state/value in infectedNodes 
  // will override the auto coloring by group, but we can deal with that later (TO DO: 1)
  const nodeColor = node => {return infectedNodes.hasOwnProperty(node.id) ? 'red' : 'lightgrey'}

  const linkColor = link => {
    const sourceInfected = infectedNodes.hasOwnProperty(link.source.id);
    const targetInfected = infectedNodes.hasOwnProperty(link.target.id);

    if (sourceInfected && targetInfected) {
      return 'orange';
    }
    return 'lightgreen'
  }

  return (
    <div style={{ width: '100vw', height: '100vh', border: '5px solid black' }}>
      <ForceGraph2D
        graphData={graphData}
        nodeLabel="id"
        linkLabel="weight"
        linkDirectionalArrowLength={3.5}
        linkDirectionalArrowRelPos={1}
        // nodeAutoColorBy="group"
        // it's abstracted from us by the framework, but an eventListener injects the dependencies in functions passed below
        onNodeClick={handleNodeClick}
        nodeColor={nodeColor}
        linkColor={linkColor}
      />
    </div>
  );
}

export default App;