import { useState, useEffect, useRef } from 'react';
import ForceGraph2D from 'react-force-graph-2d';
import { myGraphData } from './data';
import manAvatar from '../public/avatars/man.png';
import womanAvatar from '../public/avatars/woman.png';
import influencerIcon from '../public/groups/influencer.png';
import familyIcon from '../public/groups/family.png';
import followerIcon from '../public/groups/follower.png';
import friendIcon from '../public/groups/friend.png';
  
const avatarMap = {
  'man.png': manAvatar,
  'woman.png': womanAvatar
};
  
const groupIconMap = {
  'Influencer': influencerIcon,
  'Family': familyIcon,
  'Follower': followerIcon,
  'Friend': friendIcon
};

const linkWeightMap = {
  'Family': 0.3,
  'Follower': 0.9,
  'Friend': 0.6
};

// loading outside of the component to avoid reloading on each render
const loadedAvatars = {
  man: (() => { const img = new Image(); img.src = manAvatar; return img })(),
  woman: (() => { const img = new Image(); img.src = womanAvatar; return img })(),
};

const loadedGroupIcons = Object.fromEntries(
  Object.entries(groupIconMap).map(([key, src]) => {
    const img = new Image();
    img.src = src;
    return [key, img];
  })
);


function App() {
  // useState receives an initial state and returns an array with the current state and a function to update it upon changes, which is destructured into two variables
  const [graphData, setGraphData] = useState({ nodes: [], links: [] });
  const [infectedNodes, setInfectedNodes] = useState({});
  const [bfsQueue, setBfsQueue] = useState([]);
  const [delay, setDelay] = useState(1); // 500ms
  const fgRef = useRef();
  const initialNodeId = Object.keys(infectedNodes)[0];
  const [linksByNode, setLinksByNode] = useState({});

  // TO DO:
  // 1. Keep the colouring by groups? - Fuhgettaboutit
  // 2. Ensure that the red color is used exclusively for infected nodes - done
  // 3. Should all the logic be here in the App.jsx? - fuck it, yes
  // 4. improve on the probability of misinformation spread - done
  // 5. show the tree generated by the BFS? - Fuhgettaboutit
  // 6. Improve the fake news dynamic? - Fuhgettaboutit
  // 7. Função pra gerar os nós e links? - Fuhgettaboutit

  // Initilize graphData and maps links to improve BFS complexity, basically and adjacency list
  useEffect(() => {
    setGraphData(myGraphData);
    const linksMap = {};
    myGraphData.links.forEach(link => {
      const sourceId = link.source.id || link.source;
      if (!linksMap[sourceId]) {
        linksMap[sourceId] = [];
      }
      linksMap[sourceId].push(link);
    });
    setLinksByNode(linksMap);
  }, []);

  useEffect(() => {
    if (bfsQueue.length === 0) return;

    // "dequeue"
    const { id, step } = bfsQueue[0];
    const newNodesToInfect = [];
    
    // getting neighbour nodes in O(1)
    const outgoingLinks = linksByNode[id] || [];

    // run BFS
    for(const link of outgoingLinks){
      const neighbourId = link.target.id;
      let probability = linkWeightMap[link.type];
      
      // checks the node, marks and enqueue it
      if(!infectedNodes.hasOwnProperty(neighbourId) && 0.0 < Math.min(1,probability)) {
        newNodesToInfect.push({id: neighbourId, step: step + 1})
      }
    }

    setTimeout(() => {
      // this was kind of complex for me, "prev" is passed by react. React keeps watch of the value of all of variables that are using useState. So prev is actually the current value, that will be the previous value upon "return"
      setInfectedNodes( prev => {
        const newInfected = { ...prev };
        newNodesToInfect.forEach(node => {
          newInfected[node.id] = node.step;
        });
        return newInfected;
      })

      setBfsQueue(prevQueue => {
        // dequeueing for real 
        const newQueue = prevQueue.slice(1);
        return [...newQueue, ...newNodesToInfect];
      });
    // spread delay
    }, 1000 - delay*100);
  }, [bfsQueue, infectedNodes, graphData])

  useEffect(() => {
    if (fgRef.current) {
      // Repulsion force (the nodes do the pushing work)
      fgRef.current.d3Force('charge').strength(-400); 
      
      // Atraction force (the links do the pulling work)
      //fgRef.current.d3Force('link').distance(link => linkWeightMap[link.type] * 50); 
    }
  }, []);

  const handleNodeClick = (node) => {
    // Resets the graph and calls useEffect()
    setInfectedNodes({ [node.id]: 0 });
    setBfsQueue([{ id: node.id, step: 0 }]);
  };

  // both linkColor and nodeColor are called upon re-rendering of App() and catch the change of state/value in infectedNodes 
  const nodeColor = node => {return infectedNodes.hasOwnProperty(node.id) ? 'red' : 'lightgrey'}

  const linkColor = link => {
    const sourceInfected = infectedNodes.hasOwnProperty(link.source.id);
    const targetInfected = infectedNodes.hasOwnProperty(link.target.id);

    if (sourceInfected && targetInfected) {
      return 'orange';
    }
    return 'lightgreen'
  }

  return (
    <>
      {/* Legenda dos grupos */}
      <div style={{
        position: 'absolute',
        top: 20,
        left: 20,
        background: 'rgba(255,255,255,0.9)',
        border: '1px solid #ccc',
        borderRadius: '8px',
        padding: '12px 18px',
        zIndex: 10,
        boxShadow: '0 2px 8px rgba(0,0,0,0.08)',
        color: 'black'
      }}>
      <div style={{ fontWeight: 'bold', marginBottom: 8, color: 'black' }}>Legenda dos Grupos</div>
      <div style={{ display: 'flex', flexDirection: 'column', gap: 6 }}>
          <span style={{ display: 'flex', alignItems: 'center', gap: 8, color: 'black' }}>
            <img src={influencerIcon} alt="Influencer" width={20} height={20} /> Influencer
          </span>
          <span style={{ display: 'flex', alignItems: 'center', gap: 8, color: 'black' }}>
            <img src={familyIcon} alt="Family" width={20} height={20} /> Family
          </span>
          <span style={{ display: 'flex', alignItems: 'center', gap: 8, color: 'black' }}>
            <img src={followerIcon} alt="Follower" width={20} height={20} /> Follower
          </span>
          <span style={{ display: 'flex', alignItems: 'center', gap: 8, color: 'black' }}>
            <img src={friendIcon} alt="Friend" width={20} height={20} /> Friend
          </span>
        </div>
      </div>

      <div style={{ textAlign: 'center' }}>
        <h2>Simulação de Propagação de Fake News</h2>
        <p>Nós Atingidos: {Object.keys(infectedNodes).length} de {graphData.nodes.length}</p>
        <p>Passos da Propagação: {Math.max(0, ...Object.values(infectedNodes))}</p>
        {initialNodeId && <p>Nó Inicial: {initialNodeId}</p>}
      </div>

      <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', margin: '20px auto', maxWidth: '80%' }}>
        <label style={{paddingRight: '10px'}}>Intensidade da Fake News:</label>
        <input 
          type="range" 
          min="1" 
          max="10" 
          step="1" 
          value={delay} 
          onChange={(e) => setDelay(parseFloat(e.target.value))}
        />
        <span style={{paddingLeft: '10px'}}>{delay.toFixed(2)}</span>
      </div>
      <div style={{ width: '100vw', height: '100vh'}}>
        <ForceGraph2D
          ref={fgRef}
          graphData={graphData}
          nodeLabel="id"
          linkLabel="type"
          linkDirectionalArrowLength={7}
          linkDirectionalArrowRelPos={1}
          onNodeClick={handleNodeClick}
          nodeColor={nodeColor}
          linkColor={linkColor}
          nodeRelSize={13}
          nodeCanvasObject={(node, ctx, globalScale) => {
            // Choosing avatar 
            //const img = new window.Image();
            //img.src = (node.avatar === 'woman.png') ? womanAvatar : manAvatar;
            const img = node.avatar === 'woman.png' ? loadedAvatars.woman : loadedAvatars.man;
            // Choosing group icon
            const groupImg = loadedGroupIcons[node.group] || loadedGroupIcons.Friend;
            //const groupImg = new window.Image();
            //groupImg.src = groupIconMap[node.group] || friendIcon;

            // Draw colored circle (infected or not)
            ctx.save();
            ctx.beginPath();
            ctx.arc(node.x, node.y, 12, 0, 2 * Math.PI, false);
            ctx.closePath();
            ctx.lineWidth = 2;
            ctx.strokeStyle = infectedNodes.hasOwnProperty(node.id) ? 'red' : 'lightgrey';
            ctx.stroke();
            ctx.clip();
            ctx.drawImage(img, node.x - 10, node.y - 10, 20, 20);
            ctx.restore();

            // Draw group icon (bottom right corner)
            ctx.save();
            ctx.beginPath();
            ctx.arc(node.x + 8, node.y + 8, 5, 0, 2 * Math.PI, false);
            ctx.closePath();
            ctx.clip();
            ctx.drawImage(groupImg, node.x + 3, node.y + 3, 10, 10);
            ctx.restore();

            // Node name
            ctx.font = `${12/globalScale}px Sans-Serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillStyle = 'white';
            ctx.fillText(node.id, node.x, node.y + 16);
          }}
        />
      </div>
    </>
  );
}

export default App;